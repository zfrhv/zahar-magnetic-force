<!DOCTYPE html>
<html>

<head>
  <script id="Polyfill" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script id="Markdown" src="https://cdn.jsdelivr.net/gh/markedjs/marked@bf1295a499c60abc096124ab33804071cb8d89fe/marked.min.js"></script>

  <!-- instead of using npm load threejs from url -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js';
    import { OBJLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/OBJLoader.js';
    import { MTLLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/MTLLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';

    window.THREE = THREE;
    window.OBJLoader = OBJLoader;
    window.MTLLoader = MTLLoader;
    window.OrbitControls = OrbitControls;
  </script>
  <script>
    THREE = window.THREE;
    OBJLoader = window.OBJLoader;
    MTLLoader = window.MTLLoader;
    OrbitControls = window.OrbitControls;
  </script>
  <script id="CanvasVideo" src="https://canvas-video-embed.web.app/animation.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8" />

  <title>Physics</title>
  <link rel="icon" type="image/svg+xml" href="physics.svg">

  <script src="forces_integral/calculation_box.js"></script>
  <script src="tools/canvas/shapes.js"></script>
  <script src="tools/svg/shapes.js"></script>
  <script src="tools/threejs/shapes.js"></script>
  <script src="equations.js"></script>
  <link rel="stylesheet" type="text/css" href="physics.css" />
</head>

<body>
  <div class="page">
    <article class="page-content">

      <div class="markdown">
        # <center><u style="font-family: 'Times New Roman';">Bla</u></center>

        <center>(drag to rotate)</center>
      </div>

      <canvas-video name="calc_force" type="calculate"></canvas-video>
    </article>
  </div>

  <script async>
    // Parse markdown
    document.querySelectorAll('.markdown').forEach(elmNode => {
      fisrt_spaces = elmNode.innerHTML.match(/^\n*( *)[^ ]/)[1]
      elmNode.innerHTML = marked.parse(elmNode.innerHTML.replace(new RegExp("\n" + fisrt_spaces, "g"), "\n"))
    });

    function resizeIframe(obj) {
      // my videos resolution are 1920x1080
      obj.style.height = obj.offsetWidth * 1080 / 1920 + "px";
    }
  </script>
  <script async>
    function calc_force_init(toolbar, scene) {
      // draw shapes
      const geometry = new THREE.TorusGeometry( 150, 10, 20, 50 );
      const material = new THREE.MeshBasicMaterial( { color: 0xb56912 } );
      
      const wire1 = new THREE.Mesh(geometry, material);
      wire1.name = "wire1";
      wire1.speed = new THREE.Vector3( );
      wire1.rotation.x = Math.PI/2;
      wire1.position.set(0, 200, 0);
      scene.add(wire1);

      const wire2 = new THREE.Mesh(geometry, material);
      wire2.name = "wire2";
      wire2.rotation.x = Math.PI/2;
      wire2.position.set(0, -200, 0);
      scene.add(wire2);


      // create slidebars
      toolbar.style.height = toolbar.offsetWidth/3+"px";

      const slidebars = document.createElement('div');
      slidebars.style.width = "85%";
      slidebars.style.height = "100%";
      slidebars.style.textAlign = "center";
      toolbar.append(slidebars);

      const inputs = {
        "R_1": function () { wire1.rotation.x = this.value/100*Math.PI*2 + Math.PI/2 },
        "R_2": function () { wire1.rotation.y = this.value/100*Math.PI*2 },
        "R_3": function () { wire2.rotation.y = this.value/100*Math.PI*2 },
        "V_x": function () { wire1.speed.x = (this.value-50)/10 },
        "V_y": function () { wire1.speed.y = (this.value-50)/10 },
        "V_z": function () { wire1.speed.z = (this.value-50)/10 }
      }
      const height = slidebars.offsetHeight / (Object.keys(inputs).length + 2);
      slidebars.style.fontSize = height + "px";
      for(const name in inputs) {
        const part = document.createElement('div');
        part.style.width = "100%";
        part.innerText = name + ": ";
        slidebars.append(part);

        const slidebar = document.createElement('input');
        slidebar.type = 'range';
        slidebar.value = /^V_.$/.test(name) ? 50 : 0;
        slidebar.min = 0;
        slidebar.max = 100;
        slidebar.style.height = height + "px";
        slidebar.style.position = "relative";
        slidebar.style.top = height/3 + "px";
        part.append(slidebar);

        slidebar.onchange = inputs[name];
        slidebar.oninput = inputs[name];
      }
    }

    function calc_force(toolbar, scene) {
      const dir = new THREE.Vector3( 0, 1, 0 );
      dir.normalize();
      const origin = new THREE.Vector3( 0, 0, 0 );
      const length = 200;
      const hex = 0xffff00;
      const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex, 0.15*length, 0.1*length );
      scene.add(arrowHelper);

      const wire1 = {};
      const wire2 = {};

      const wire1_mesh = scene.getObjectByName("wire1");
      const wire2_mesh = scene.getObjectByName("wire2");

      wire1.radius = wire1_mesh.geometry.parameters.radius;
      wire1.position = wire1_mesh.position;
      wire1.rotation = new THREE.Vector3(0, 0, 1).applyEuler(wire1_mesh.rotation);
      wire1.speed = wire1_mesh.speed;

      wire2.radius = wire2_mesh.geometry.parameters.radius;
      wire2.position = wire2_mesh.position;
      wire2.rotation = new THREE.Vector3(0, 0, 1).applyEuler(wire2_mesh.rotation);

      console.log(wire1)

      const F_1_T = new THREE.Vector3();
      const F_2_T = new THREE.Vector3();
      const F_1_rotating_T = new THREE.Vector3();
      const F_2_rotating_T = new THREE.Vector3();
      let Voltage_2 = 0;
      const parts = 16;

      // finding dot
      const new_x_1 = Math.round(wire1.rotation.x/wire1.rotation.norm(), 4) == 0 ? wire1.rotation.cross_product(vector([1,0,0])).normalized() : wire1.rotation.cross_product(vector([0,1,0])).normalized();

      const new_y_1 = wire1.rotation.cross_product(new_x_1)
      new_x_1 = new_x_1*wire1.rotation.norm()
    }
  </script>
</body>

</html>