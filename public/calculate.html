<!DOCTYPE html>
<html>

<head>
  <script id="Polyfill" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script id="Markdown" src="https://cdn.jsdelivr.net/gh/markedjs/marked@bf1295a499c60abc096124ab33804071cb8d89fe/marked.min.js"></script>

  <!-- instead of using npm load threejs from url -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js';
    import { OBJLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/OBJLoader.js';
    import { MTLLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/MTLLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';

    window.THREE = THREE;
    window.OBJLoader = OBJLoader;
    window.MTLLoader = MTLLoader;
    window.OrbitControls = OrbitControls;
  </script>
  <script>
    THREE = window.THREE;
    OBJLoader = window.OBJLoader;
    MTLLoader = window.MTLLoader;
    OrbitControls = window.OrbitControls;
  </script>
  <script id="CanvasVideo" src="https://canvas-video-embed.web.app/animation.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8" />

  <title>Physics</title>
  <link rel="icon" type="image/svg+xml" href="physics.svg">

  <script src="forces_integral/calculation_box.js"></script>
  <script src="tools/canvas/shapes.js"></script>
  <script src="tools/svg/shapes.js"></script>
  <script src="tools/threejs/shapes.js"></script>
  <script src="equations.js"></script>
  <link rel="stylesheet" type="text/css" href="physics.css"/>
</head>

<body>
  <div class="page">
    <article class="page-content">

      <div class="markdown">
        # <center><u style="font-family: 'Times New Roman';">Bla</u></center>

        TODO:
        - tell how i discovered the function
        - show that the forces are the same (total force + rotation force)
        - explain that moving wire 1 can cause volate in wire2
        - then explain that when current changes inside wire, in my opinion its just differente charges that cause volatage
        - then show that with this equation, when friction/wire changes -> v/q changes, the force is still the same !

        <center>(drag to rotate)</center>
        symbols:
        - rotating arrow...
        - straight arrow...
        usage:
        - toggle switch is for force type
        - inputs are for rotation (drag/tap to choose)
        - you can also rotate the object just by dragging it
        - you can also zoom in or zoom out with fingers / mouse scroll
        - you can also move in space by gragging with 2 fingers in the same direction or with keyboard arrows
        - refresh the page to reset
      </div>

      <details style="text-align: center;">
        <summary>Inscructions of how to use <a href="#calc_force">this</a> tool</summary>
        <div style="text-align: left;">
          <div class="markdown">
            - When the switch is off then the right hand law equation used, when its on then my new equation is used.

            - The slider is to how many parts to split the wires, more slices -> more accuracy. but its also harder to calculate.

            - Pressing the calculator will calculate the forces.

            - The filled arrows are the force, green arrow = the force that the green wire creates. same with purple arrow.

            - The round arrows are how much the object wants to rotate, the green round arrow = how much the green wire wants to rotate the purple wire. same with purple round arrow.

            - If you understand a little in svg path and programming, feel free to change the path by pressing f12 -> searching for "path" with "class=wire1" or "class=wire2" (just select the wire you want to modify),
              change the "d="" field to the desired path, and then just press the clculator button again.

            - after pressing the calculate button, the force of the orange object is printed to the logs (you can see \\(F_x\\) and \\(F_y\\) in console logs)
          </div>
        </div>
      </details>

      <canvas-video id="calc_force" name="calc_force" type="calculate" style="width: 70%;"></canvas-video>
    </article>
  </div>

  <script async>
    // Parse markdown
    document.querySelectorAll('.markdown').forEach(elmNode => {
      fisrt_spaces = elmNode.innerHTML.match(/^\n*( *)[^ ]/)[1]
      elmNode.innerHTML = marked.parse(elmNode.innerHTML.replace(new RegExp("\n" + fisrt_spaces, "g"), "\n"))
    });

    function resizeIframe(obj) {
      // my videos resolution are 1920x1080
      obj.style.height = obj.offsetWidth * 1080 / 1920 + "px";
    }
  </script>
  <script async>
    const pi = Math.PI;

    function calc_force_init(toolbar, scene) {
      // draw shapes
      const wire_shape = new THREE.TorusGeometry( 150, 10, 20, 50 )
      
      const wire1 = new THREE.Group()
      const wire1_material = new THREE.MeshBasicMaterial({ color: 0x3e8207 })
      wire1.name = "wire1"

      const wire1_shape = new THREE.Mesh(wire_shape, wire1_material)
      wire1_shape.name = "wire_shape"
      wire1.add(wire1_shape)

      const arrow_1 = new THREE.Mesh(new THREE.ConeGeometry( 25, 35, 32 ), wire1_material)
      arrow_1.position.y = 150
      arrow_1.rotation.z = -pi / 2
      wire1.add(arrow_1)

      const arrow_2 = new THREE.Mesh(new THREE.ConeGeometry( 25, 35, 32 ), wire1_material)
      arrow_2.position.y = -150
      arrow_2.rotation.z = pi / 2
      wire1.add(arrow_2)

      const arrow_3 = new THREE.Mesh(new THREE.ConeGeometry( 25, 35, 32 ), wire1_material)
      arrow_3.position.x = 150
      arrow_3.rotation.z = pi
      wire1.add(arrow_3)

      const arrow_4 = new THREE.Mesh(new THREE.ConeGeometry( 25, 35, 32 ), wire1_material)
      arrow_4.position.x = -150
      wire1.add(arrow_4)

      wire1.rotation.x = pi/2
      wire1.position.y = 200
      scene.add(wire1)

      const wire2_material = new THREE.MeshBasicMaterial({ color: 0x6898cc })
      const wire2 = wire1.clone()
      wire2.name = "wire2";
      wire2.position.y = -200
      wire2.traverse((node) => { if (node.isMesh) { node.material = wire2_material } })
      scene.add(wire2)

      // total force arrows
      const force_on_1 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), wire1.position, 0, wire2_material.color);
      force_on_1.name = "force_on_1";
      scene.add(force_on_1);

      const force_on_2 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), wire2.position, 0, wire1_material.color);
      force_on_2.name = "force_on_2";
      scene.add(force_on_2);

      // rotation force arrows
      const circle = new THREE.EllipseCurve(0, 0, 80, 80, 0, 3/2 * pi, false);
      const points = circle.getSpacedPoints(10);
      const curve_1_body = new THREE.Line(new THREE.Path().createGeometry(points));
      const curve_1_head = new THREE.Mesh(new THREE.ConeGeometry( 15, 40, 32 ));
      curve_1_head.position.y = -80
      curve_1_head.rotation.z = -pi / 2

      const curve_1 = new THREE.Group()
      curve_1.add(curve_1_body)
      curve_1.add(curve_1_head)
      const curve_2 = curve_1.clone()
      curve_2.traverse((node) => { if (node.isMesh) { node.material = node.material.clone() } })

      curve_1.name = "curve_1"
      curve_2.name = "curve_2"

      curve_1.position.set(wire1.position.x, wire1.position.y, wire1.position.z)
      curve_2.position.set(wire2.position.x, wire2.position.y, wire2.position.z)

      curve_1.children.forEach(child => { child.material.color.set(wire2_material.color) })
      curve_2.children.forEach(child => { child.material.color.set(wire1_material.color) })

      curve_1.scale.set(0,0,0)
      curve_2.scale.set(0,0,0)

      scene.add(curve_1)
      scene.add(curve_2)

      // create force toggle
      const toggle_force = document.createElement('label');
      toggle_force.style.height = "20%";
      toggle_force.style.width = "60%";
      toggle_force.style.margin = "20%";
      toggle_force.classList.add("switch");
      toolbar.children[0].append(toggle_force);

      const input = document.createElement('input');
      input.classList.add("force_type");
      input.type = "checkbox";
      toggle_force.append(input);

      const span = document.createElement('span');
      span.classList.add("slider");
      span.classList.add("round");
      toggle_force.append(span);
      
      const p = document.createElement('p');
      span.append(p);


      // create slidebars
      toolbar.style.height = toolbar.offsetWidth/3+"px";

      const slidebars = document.createElement('div');
      slidebars.style.width = "85%";
      slidebars.style.height = "100%";
      slidebars.style.textAlign = "center";
      toolbar.append(slidebars);

      const inputs = {
        "R_1": function () { wire1.rotation.x = this.value/100*pi*2 + pi/2 },
        "R_2": function () { wire1.rotation.y = this.value/100*pi*2 },
        "R_3": function () { wire2.rotation.y = this.value/100*pi*2 }
      }
      const height = slidebars.offsetHeight / (Object.keys(inputs).length);
      slidebars.style.fontSize = height*0.8 + "px";
      for(const name in inputs) {
        const part = document.createElement('div');
        part.innerText = name + ": ";
        slidebars.append(part);

        const slidebar = document.createElement('input');
        slidebar.type = 'range';
        slidebar.value = 0;
        slidebar.min = 0;
        slidebar.max = 100;
        slidebar.style.width = "60%";
        slidebar.style.verticalAlign = "middle";
        slidebar.classList.add("measure_slide");
        part.append(slidebar);

        slidebar.onchange = inputs[name];
        slidebar.oninput = inputs[name];
      }
    }

    function calc_force(toolbar, scene) {
      const wire1 = {};
      const wire2 = {};

      const wire1_mesh = scene.getObjectByName("wire1")
      const wire2_mesh = scene.getObjectByName("wire2")
      const force_on_1 = scene.getObjectByName("force_on_1")
      const force_on_2 = scene.getObjectByName("force_on_2")
      const curve_1    = scene.getObjectByName("curve_1")
      const curve_2    = scene.getObjectByName("curve_2")

      wire1.radius = wire1_mesh.getObjectByName("wire_shape").geometry.parameters.radius;
      wire1.position = wire1_mesh.position;
      wire1.rotation = new THREE.Vector3(0, 0, 1).applyEuler(wire1_mesh.rotation);

      wire2.radius = wire2_mesh.getObjectByName("wire_shape").geometry.parameters.radius;
      wire2.position = wire2_mesh.position;
      wire2.rotation = new THREE.Vector3(0, 0, 1).applyEuler(wire2_mesh.rotation);

      const mine_force = toolbar.children[0].children[1].children[0].checked;

      const F_1_T = new THREE.Vector3();
      const F_2_T = new THREE.Vector3();
      const F_1_rotating_T = new THREE.Vector3();
      const F_2_rotating_T = new THREE.Vector3();
      const parts = 200;

      // creating new axis on circles
      const new_x_1 = Math.round(wire1.rotation.x, 4) == 0 ? wire1.rotation.clone().cross(new THREE.Vector3(1,0,0)) : wire1.rotation.clone().cross(new THREE.Vector3(0,1,0))
      new_x_1.normalize().multiplyScalar(wire1.radius)
      const new_y_1 = wire1.rotation.clone().cross(new_x_1)

      const new_x_2 = Math.round(wire2.rotation.x, 4) == 0 ? wire2.rotation.clone().cross(new THREE.Vector3(1,0,0)) : wire2.rotation.clone().cross(new THREE.Vector3(0,1,0))
      new_x_2.normalize().multiplyScalar(wire2.radius)
      const new_y_2 = wire2.rotation.clone().cross(new_x_2);

      for (let part1 = 0; part1 < parts; part1++) {
        for (let part2 = 0; part2 < parts; part2++) {
          const alpha = 2*pi * part1/parts;
          const beta  = 2*pi * part2/parts;

          const relative_place_1 = new_x_1.clone().multiplyScalar(Math.sin(alpha)).add(new_y_1.clone().multiplyScalar(Math.cos(alpha)));
          const relative_place_2 = new_x_2.clone().multiplyScalar(Math.sin(beta)).add(new_y_2.clone().multiplyScalar(Math.cos(beta)));

          const v_1 = wire1.rotation.clone().cross(relative_place_1).normalize();
          const v_2 = wire2.rotation.clone().cross(relative_place_2).normalize();

          const absolute_place_1 = wire1.position.clone().add(relative_place_1)
          const absolute_place_2 = wire2.position.clone().add(relative_place_2)

          const R = absolute_place_1.sub(absolute_place_2)
          const R_hat = R.clone().normalize()

          let f_1 = null
          let f_2 = null

          if (mine_force) {
            // very simplified "mine" force calculation
            f_2 = R_hat.clone().multiplyScalar( v_1.clone().dot(v_2) / (Math.pow(R.length(), 2)) )
            f_1 = f_2.clone().negate()
          } else {
            // "their" force calculation
            f_1 = v_2.clone().cross(R_hat.clone().negate()).cross(v_1).divideScalar(Math.pow(R.length(), 2))
            f_2 = v_1.clone().cross(R_hat                 ).cross(v_2).divideScalar(Math.pow(R.length(), 2))
          }

          F_1_T.add(f_1)
          F_2_T.add(f_2)

          F_1_rotating_T.add(relative_place_1.clone().cross(f_1))
          F_2_rotating_T.add(relative_place_2.clone().cross(f_2))
        }
      }

      // add dx
      F_1_T.divideScalar(parts*parts)
      F_2_T.divideScalar(parts*parts)
      F_1_rotating_T.divideScalar(parts*parts)
      F_2_rotating_T.divideScalar(parts*parts)

      // scale forces to equal values
      const foce_const = 267079464.85
      F_1_T.multiplyScalar(foce_const)
      F_2_T.multiplyScalar(foce_const)
      F_1_rotating_T.multiplyScalar(foce_const*2/3)
      F_2_rotating_T.multiplyScalar(foce_const*2/3)

      // update total force arrows
      force_on_1.setDirection(F_1_T.clone().normalize())
      force_on_1.setLength(F_1_T.length(), F_1_T.length()*0.2, F_1_T.length()*0.2)
      force_on_2.setDirection(F_2_T.clone().normalize())
      force_on_2.setLength(F_2_T.length(), F_2_T.length()*0.2, F_2_T.length()*0.2)

      // update rotation force arrows
      const scale_1 = F_1_rotating_T.length() / 20500
      const scale_2 = F_2_rotating_T.length() / 20500

      curve_1.scale.set(scale_1, scale_1, scale_1)
      curve_2.scale.set(scale_2, scale_2, scale_2)

      const rotation_1_direction = F_1_rotating_T.clone().normalize()
      const rotation_2_direction = F_2_rotating_T.clone().normalize()

      if (Math.round(rotation_1_direction.y,10) == 0 && Math.round(rotation_1_direction.z,10) == 0) {
        curve_1.rotation.x = 0
      } else {
        curve_1.rotation.x = Math.atan2(rotation_1_direction.y, rotation_1_direction.z)
      }
      if (Math.round(rotation_2_direction.y,10) == 0 && Math.round(rotation_2_direction.z,10) == 0) {
        curve_2.rotation.x = 0
      } else {
        curve_2.rotation.x = Math.atan2(rotation_2_direction.y, rotation_2_direction.z)
      }
      curve_1.rotation.y = Math.asin(rotation_1_direction.x)
      curve_2.rotation.y = Math.asin(rotation_2_direction.x)
    }
  </script>
</body>

</html>