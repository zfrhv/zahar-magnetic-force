<!DOCTYPE html>
<html>

<head>
  <script id="Polyfill" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script id="Markdown" src="https://cdn.jsdelivr.net/gh/markedjs/marked@bf1295a499c60abc096124ab33804071cb8d89fe/marked.min.js"></script>

  <!-- Import maps polyfill -->
	<!-- Remove this when import-maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script id="ThreeJS" type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.144.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.144.0/examples/jsm/"
      }
    }
  </script>
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8" />

  <title>Physics</title>
  <link rel="icon" type="image/svg+xml" href="physics.svg">

  <script src="tools/canvas/shapes.js"></script>
  <script src="equations.js"></script>
  <link rel="stylesheet" type="text/css" href="physics.css"/>
</head>

<body>
  <script id="SideBar" src="./sidebar/sidebar.js"></script>
  
  <div class="page">
    <article class="page-content">

      <div class="markdown">
        # <center><u style="font-family: 'Times New Roman';">Magnetic Force Equation</u></center>

        Diagram of symbols:
        <br/>
        <br/>
      </div>
      <div id="equation_anatomy" class="animation_box">
        <canvas width="1000" height="1000"></canvas>
      </div>
      <div class="markdown">
        \\({\color{Tomato}\vec A}\ \parallel\ {\color{MediumSeaGreen}\vec B}={\color{GoldenRod}\vec C}\\):

        \\({\color{Tomato}\vec A}\ \bot\ {\color{MediumSeaGreen}\vec B}={\color{DodgerBlue}\vec D}\\):
      </div>
      <div id="vertical_symbol" class="animation_box">
        <canvas width="1000" height="1000"></canvas>
      </div>
      <div class="markdown">
        $$\color{#f7c860}I = q \cdot v$$
        $$\color{#f7c860}\vec{v}\ \parallel\ \hat{r}\ :=\ (\vec{v} \cdot \hat{r}) \cdot \hat{r}$$
        $$\color{#f7c860}\vec{v}\ \bot\ \hat{r}\ :=\ \vec{v} - (\vec{v} \cdot \hat{r}) \cdot \hat{r}$$


        # <center><u style="font-family: 'Times New Roman';">How I found the function</u></center>
        Lets start from the things i didnt like, and start making a new equation.
        1. i will choose the force to be in \\(\hat{r}\\) direction.
        2. when moving in 3d dimention is some direction, everything expands in 2d face,

            its like measuring the surface of a ball \\ square at distance x, lets say its around \\(x^2\\). then looking on surface at the same degree with distance 2x, the surface extended to \\((2x)^2\\) which is \\(4x^2\\), so the area grew by 4.

            and thats why when we will move \\(a\\) times, the area will expand \\(a^2\\) times. and a particular spot will have less material by \\(\frac{1}{a^2}\\)

            so the quation will be \\(F = \frac{something}{r^2}\\)
        3. When the equation tells that \\(\vec{F} = \vec{v}\ \times\ \vec{B}\\), relative to what the speed \\(\vec{v}\\) is ?

            is it relative to the material where the electrons are in?

            is it relative the some absolute speed that i decide?

            is it relative to the material of the original wire which caused the magnetic field?

            well in my opition if the force is between particle A and B, then the speed of A will be relative to B.

            so the equation sould look something like this: \\(\vec{v_1}-\vec{v_2}\\)

        4. now if we check the equation units, we actually have speed\\(^2\\) and not jus speed.

            so why not to make \\((\vec{v_1}-\vec{v_2})^2\\) ? its good for us, because now the equation is symetric, no matter from which perspective you look the result is the same

        5. dont forget to multiply by the charge q: \\((\vec{v_1}-\vec{v_2})^2 \cdot q_1 \cdot q_2\\) and now we will have something similar to units of \\(I_1 \cdot I_2\\)

        6. but we have a new problem, the result is always positive, does it means that we will always end up with pulling force?

            yes, thats why we need to find something else that will give us also negative result. and if we look at the Coulomb's law, there is +q and -q...

            now why exactly are we ignoring the positive charge? the wire is nutral right? then why do we look only on the negative electrons, and ignore the positive charges?

            thats racist! (not really), if we look at -q of moving electrons, then we also look at +q of the protons with 0 speed.

            and now we end up with 2 parts from each wire, positive and negative:

        $$F = \begin{aligned}
            \frac{(\vec{v_1}_\+ - \vec{v_2}_\-)^2 \cdot {q_1}_\+ \cdot {q_2}_\-}{r^2} \\\\
            \+ \frac{(\vec{v_1}_\- - \vec{v_2}_\+)^2 \cdot {q_1}_\- \cdot {q_2}_\+}{r^2} \\\\
            \+ \frac{(\vec{v_1}_\- - \vec{v_2}_\-)^2 \cdot {q_1}_\- \cdot {q_2}_\-}{r^2} \\\\
            \+ \frac{(\vec{v_1}_\+ - \vec{v_2}_\+)^2 \cdot {q_1}_\+ \cdot {q_2}_\+}{r^2} \end{aligned}$$

        7. but lets focuse on seperating to 4 parts later. i was wondering, from perspective of particle 1 all he sees is particle 2 getting closer and further, what the ronning around speed doesnt matters, the only speed that matters if particle 2 gets closer or further:

            \\((\vec{v_1} \cdot \hat{r}-\vec{v_2} \cdot \hat{r})^2\\) which is the same as \\(((\vec{v_1}-\vec{v_2}) \cdot \hat{r})^2\\)

        8. now when doing the integral between 2 circle wires to check the total force result with my new equation, it was perfectly the same as the total force with the right hand law equation.

            but the rotation force was different. each equation told that the circuit would want to rotate in a different way.

            now i assume that people from all around the world did many experiments and had many practice with the right hand law, so their rotation must be correct.

            thats why i also checked whats the rotation when using just simple \\((\vec{v_1}-\vec{v_2})^2\\). it also had rotation problem so i also checked when the speeds were vertical to the r direction, but the rotation was still wrong.

            but i did noticed that i got close, and i saw that when doing \\((\vec{v_1}-\vec{v_2}) \parallel \hat{r})^2 -0.5 ((\vec{v_1}-\vec{v_2}) \bot \hat{r})^2\\) i get the perfect total force, and the perfect rotation.

            TODO: you can see it in THAT diagram

        $$\vec{F} = \frac{Constant \cdot q_1 \cdot q_2 \cdot Top\ Part}{\vec{r}\ ^2}$$
        <br/>
        $$Top\ Part = \begin{aligned}
        \+ ((\vec{v_1} - \vec{v_2})\ \bot\ \hat{r})^2 \\\\
        \- ((\vec{v_1} - \vec{v_2})\ \parallel\ \hat{r})^2\ /\ 2 \end{aligned}$$
        <br/>
      </div>
      <details style="text-align: center;">
        <summary>Simplification: (click on this text)</summary>
        <div style="text-align: left;">
          <div class="markdown">
            $$2 \cdot Top\ Part = \begin{aligned}
            \+ ((\vec{v_1} - \vec{v_2})\ \bot\ \hat{r})^2\ \cdot\ 2 \\\\
            \- ((\vec{v_1} - \vec{v_2})\ \parallel\ \hat{r})^2 \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = \begin{aligned}
            \+ ((\vec{v_1} - \vec{v_2}) - ((\vec{v_1} - \vec{v_2}) \cdot \hat{r}) \cdot \hat{r})^2\ \cdot\ 2 \\\\
            \- (((\vec{v_1} - \vec{v_2}) \cdot \hat{r}) \cdot \hat{r})^2 \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = \begin{aligned}
            \+ ((\vec{v_1} - \vec{v_2}) - (\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2\ \cdot\ 2 \\\\
            \- ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2 \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = \begin{aligned}
            \+ ((\vec{v_1} - \vec{v_2}) - (\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2\ \cdot\ 2 \\\\
            \- ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2 \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = \begin{aligned}
            \+ ((\vec{v_1} - \vec{v_2})^2 - 2 \cdot (\vec{v_1} - \vec{v_2}) \cdot ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r}) + ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2)\ \cdot\ 2 \\\\
            \- ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2 \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = \begin{aligned}
            \+ 2(\vec{v_1} - \vec{v_2})^2 - 4(\vec{v_1} - \vec{v_2}) \cdot ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r}) + {\color{#76de76}2}((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2 \\\\
            \color{#76de76}\- ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2 \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = 2(\vec{v_1} - \vec{v_2})^2 - 4(\vec{v_1} - \vec{v_2}) \cdot ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r}) + ((\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot \hat{r})^2 $$
            <br/>
            $$\color{#f7c860}(s \cdot \hat{v})^2 = s^2 \cdot \hat{v}^2 = s^2 \cdot 1 = s^2$$
            <br/>
            $$2 \cdot Top\ Part = 2(\vec{v_1} - \vec{v_2})^2 - 4(\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) \cdot (\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r}) + (\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r})^2 $$
            <br/>
            $$2 \cdot Top\ Part = 2(\vec{v_1} - \vec{v_2})^2 - {\color{#76de76}4}(\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r})^2 \color{#76de76} + (\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r})^2 $$
            <br/>
            $$2 \cdot Top\ Part = 2(\vec{v_1} - \vec{v_2})^2 - 3(\vec{v_1} \cdot \hat{r} - \vec{v_2} \cdot \hat{r})^2 $$      
            <br/>
            $$\color{#f7c860} Top\ Part = (\vec{v_1} - \vec{v_2})^2 - 3/2((\vec{v_1} - \vec{v_2}) \cdot \hat{r})^2 $$      
          </div>
        </div>
      </details>
      <div class="markdown">
        So the equation is:

        $$\color{#f7c860} \vec{F} = \frac{Constant \cdot q_1 \cdot q_2 \cdot ((\vec{v_1} - \vec{v_2})^2 - 3/2((\vec{v_1} - \vec{v_2}) \cdot \hat{r})^2)}{\vec{r}\ ^2} \cdot \hat{r}$$

      </div>
      <details style="text-align: center;">
        <summary>And if we check between wires, there are 4 parts: (click on this text)</summary>
        <div style="text-align: left;">
          <div class="markdown">
            $$2 \cdot Top\ Part = \begin{aligned}
            {\color{#fc9a88} {q_1}_\+ + {q_2}_\- \rightarrow} + 2(\vec{v_1}_\+ - \vec{v_2}_\-)^2 - 3(\vec{v_1}_\+ \cdot \hat{r} - \vec{v_2}_\- \cdot \hat{r})^2 \\\\
            {\color{#fc9a88} {q_1}_\- + {q_2}_\+ \rightarrow} + 2(\vec{v_1}_\- - \vec{v_2}_\+)^2 - 3(\vec{v_1}_\- \cdot \hat{r} - \vec{v_2}_\+ \cdot \hat{r})^2 \\\\
            {\color{#fc9a88} {q_1}_\- + {q_2}_\- \rightarrow} - 2(\vec{v_1}_\- - \vec{v_2}_\-)^2 + 3(\vec{v_1}_\- \cdot \hat{r} - \vec{v_2}_\- \cdot \hat{r})^2 \\\\
            {\color{#fc9a88} {q_1}_\+ + {q_2}_\+ \rightarrow} - 2(\vec{v_1}_\+ - \vec{v_2}_\+)^2 + 3(\vec{v_1}_\+ \cdot \hat{r} - \vec{v_2}_\+ \cdot \hat{r})^2 \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = \begin{aligned}
            \+ 2(\vec{v_1}_\+^2 - 2 \cdot \vec{v_1}_\+ \cdot \vec{v_2}_\- + \vec{v_2}_\-^2) - 3((\vec{v_1}_\+ \cdot \hat{r})^2 - 2 \cdot (\vec{v_1}_\+ \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) + (\vec{v_2}_\- \cdot \hat{r})^2) \\\\
            \+ 2(\vec{v_1}_\-^2 - 2 \cdot \vec{v_1}_\- \cdot \vec{v_2}_\+ + \vec{v_2}_\+^2) - 3((\vec{v_1}_\- \cdot \hat{r})^2 - 2 \cdot (\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\+ \cdot \hat{r}) + (\vec{v_2}_\+ \cdot \hat{r})^2) \\\\
            \- 2(\vec{v_1}_\-^2 - 2 \cdot \vec{v_1}_\- \cdot \vec{v_2}_\- + \vec{v_2}_\-^2) + 3((\vec{v_1}_\- \cdot \hat{r})^2 - 2 \cdot (\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) + (\vec{v_2}_\- \cdot \hat{r})^2) \\\\
            \- 2(\vec{v_1}_\+^2 - 2 \cdot \vec{v_1}_\+ \cdot \vec{v_2}_\+ + \vec{v_2}_\+^2) + 3((\vec{v_1}_\+ \cdot \hat{r})^2 - 2 \cdot (\vec{v_1}_\+ \cdot \hat{r}) \cdot (\vec{v_2}_\+ \cdot \hat{r}) + (\vec{v_2}_\+ \cdot \hat{r})^2) \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = \begin{aligned}
            {\color{#76de76} \+ 2\vec{v_1}_\+^2} - 4\vec{v_1}_\+ \cdot \vec{v_2}_\- {\color{#76de76} + 2\vec{v_2}_\-^2 - 3(\vec{v_1}_\+ \cdot \hat{r})^2} + 6(\vec{v_1}_\+ \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) \color{#76de76} - 3(\vec{v_2}_\- \cdot \hat{r})^2 \\\\
            {\color{#76de76} \+ 2\vec{v_1}_\-^2} - 4\vec{v_1}_\- \cdot \vec{v_2}_\+ {\color{#76de76} + 2\vec{v_2}_\+^2 - 3(\vec{v_1}_\- \cdot \hat{r})^2} + 6(\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\+ \cdot \hat{r}) \color{#76de76} - 3(\vec{v_2}_\+ \cdot \hat{r})^2 \\\\
            {\color{#76de76} \- 2\vec{v_1}_\-^2} + 4\vec{v_1}_\- \cdot \vec{v_2}_\- {\color{#76de76} - 2\vec{v_2}_\-^2 + 3(\vec{v_1}_\- \cdot \hat{r})^2} - 6(\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) \color{#76de76} + 3(\vec{v_2}_\- \cdot \hat{r})^2 \\\\
            {\color{#76de76} \- 2\vec{v_1}_\+^2} + 4\vec{v_1}_\+ \cdot \vec{v_2}_\+ {\color{#76de76} - 2\vec{v_2}_\+^2 + 3(\vec{v_1}_\+ \cdot \hat{r})^2} - 6(\vec{v_1}_\+ \cdot \hat{r}) \cdot (\vec{v_2}_\+ \cdot \hat{r}) \color{#76de76} + 3(\vec{v_2}_\+ \cdot \hat{r})^2 \end{aligned}$$
            <br/>
            $$2 \cdot Top\ Part = \begin{aligned}
            \- 4\vec{v_1}_\+ \cdot \vec{v_2}_\- + 6(\vec{v_1}_\+ \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) \\\\
            \- 4\vec{v_1}_\- \cdot \vec{v_2}_\+ + 6(\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\+ \cdot \hat{r}) \\\\
            \+ 4\vec{v_1}_\- \cdot \vec{v_2}_\- - 6(\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) \\\\
            \+ 4\vec{v_1}_\+ \cdot \vec{v_2}_\+ - 6(\vec{v_1}_\+ \cdot \hat{r}) \cdot (\vec{v_2}_\+ \cdot \hat{r}) \end{aligned}$$
            <br/>
            $$Top\ Part = \begin{aligned}
            \- 2\vec{v_1}_\+ \cdot \vec{v_2}_\- + 3(\vec{v_1}_\+ \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) \\\\
            \- 2\vec{v_1}_\- \cdot \vec{v_2}_\+ + 3(\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\+ \cdot \hat{r}) \\\\
            \+ 2\vec{v_1}_\- \cdot \vec{v_2}_\- - 3(\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) \\\\
            \+ 2\vec{v_1}_\+ \cdot \vec{v_2}_\+ - 3(\vec{v_1}_\+ \cdot \hat{r}) \cdot (\vec{v_2}_\+ \cdot \hat{r}) \end{aligned}$$
    
            But in real life when we measure force between the wires, the material is not moving, so the speed of the protons is 0:
    
            $$Top\ Part = 2\vec{v_1}_\- \cdot \vec{v_2}_\- - 3(\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}) $$
    
            So we will get:
    
            $$\vec{F} = \frac{Constant \cdot q_1 \cdot q_2 \cdot (2\vec{v_1}_\- \cdot \vec{v_2}_\- - 3(\vec{v_1}_\- \cdot \hat{r}) \cdot (\vec{v_2}_\- \cdot \hat{r}))}{2\vec{r}\ ^2}$$
            <br/>
            $$\vec{F} = \frac{Constant \cdot q_1 \cdot q_2 \cdot (2 \cdot |v_1| \cdot |v_2| \cdot \hat{v_1}_\- \cdot \hat{v_2}_\- - 3(|v_1| \cdot \hat{v_1}_\- \cdot \hat{r}) \cdot (|v_2| \cdot \hat{v_2}_\- \cdot \hat{r}))}{2\vec{r}\ ^2}$$
            <br/>
            $$\vec{F} = \frac{Constant \cdot q_1 \cdot q_2 \cdot |v_1| \cdot |v_2| \cdot (2 \cdot \hat{v_1}_\- \cdot \hat{v_2}_\- - 3(\hat{v_1}_\- \cdot \hat{r}) \cdot (\hat{v_2}_\- \cdot \hat{r}))}{2\vec{r}\ ^2}$$
            <br/>
            <div id="lol">
            $$\vec{F} = \frac{Constant \cdot |I_1| \cdot |I_2| \cdot (2 \cdot \hat{I_1} \cdot \hat{I_2} - 3(\hat{I_1} \cdot \hat{r}) \cdot (\hat{I_2} \cdot \hat{r}))}{2\vec{r}\ ^2}$$    
            </div>
          </div>
        </div>
      </details>
      <div class="markdown">
        Final equation:
        $$\color{#f7c860} Force\ between\ two\ wire\ parts = \frac{Constant \cdot |I_1| \cdot |I_2| \cdot (\hat{I_1} \cdot \hat{I_2} - 3/2(\hat{I_1} \cdot \hat{r}) \cdot (\hat{I_2} \cdot \hat{r}))}{\vec{r}\ ^2} \cdot \hat{r}$$
        when the constant is:
        $$\color{#f7c860} Constant = \frac{Î¼_0}{4\pi}$$

        # Now about the "changing magnetic field"

        when current changes its charges blah blah

        when wire is being moved its like giving extra speed to the particles.

        # <center><u style="font-family: 'Times New Roman';">Changing magnetic field</u></center>

        ## Changing current inside the wire

        in my opinion, when a current changes, there is some charge difference as a result in the wire, which causes voltage in other wire.

        when the battery is keep increasing the voltage, the current is keep increasing.

        it takes time fo the current to get bigger from one end to the other end of the wire, so we end up with one side of the battery where there are a log of electrons, and the other side has a lot less electrons.

        and then as we go over the wire from one end to the other, the amount of charge is changing.

        so no matter at which spot inside the wire we will look at, from one side we will see more charge than from the other side.

        and when we look on second wire spot, it will have some static force (Coulomb's law) thats pushed the electron to some side, which causes voltage

        ## Moving wire

        when wire moves its same as the protons + electrons get some speed,

        so we can simply measure whats the force that is being made on the electrons in the other wire, and then do (force/q)*distance to get the voltage.

        calculating that way gives almost exactly the same results as the Faraday's Law.

        TODO: you can see it THERE

        what about the force on protons? well i think it also should matter, but because the proton is so heavy relative to the electron, even if he will have some movement its basically nothing relative to the electron.

        so i just ignore the force on the electron when calculating the voltage.

        # <center><u style="font-family: 'Times New Roman';">Notes</u></center>

        if you look at the [short equation](#lol), you can see that the value of I ilinear inside the equation.

        so even if inside the wire the resistence changes, or the pressure changes, or the speed changes, it doesnt matters. because as long as q*v=I, the equation will still have the same result even if v changes (because I is stable).

        <center>(drag to rotate)</center>
        symbols:
        - rotating arrow...
        - straight arrow...
        usage:
        - toggle switch is for force type
        - inputs are for rotation (drag/tap to choose)
        - you can also rotate the object just by dragging it
        - you can also zoom in or zoom out with fingers \\ mouse scroll
        - you can also move in space by gragging with 2 fingers in the same direction or with keyboard arrows
        - refresh the page to reset

        TODO show them many positions, includint when both wires are a bit skewec (R_2 and R_3) like wire 1 moved a bit, and also add speed to it and show that its almost the same voltage
      </div>

      <details style="text-align: center;">
        <summary>Inscructions of how to use <a href="#calc_force">this</a> tool (click on this text)</summary>
        <div style="text-align: left;">
          <div class="markdown">
            - When the switch is off then the right hand law equation used, when its on then my new equation is used.

            - The slider is to how many parts to split the wires, more slices -> more accuracy. but its also harder to calculate.

            - Pressing the calculator will calculate the forces.

            - The filled arrows are the force, green arrow = the force that the green wire creates. same with purple arrow.

            - The round arrows are how much the object wants to rotate, the green round arrow = how much the green wire wants to rotate the purple wire. same with purple round arrow.

            - If you understand a little in svg path and programming, feel free to change the path by pressing f12 -> searching for "path" with "class=wire1" or "class=wire2" (just select the wire you want to modify),
              change the "d="" field to the desired path, and then just press the clculator button again.

            - after pressing the calculate button, the force of the orange object is printed to the logs (you can see \\(F_x\\) and \\(F_y\\) in console logs)
          </div>
        </div>
      </details>
      <br/>
      <canvas-video id="calc_force" name="calc_force" type="calculate" style="width: 70%; position: relative;"></canvas-video>
    </article>
  </div>

  <script async>
    // Parse markdown
    document.querySelectorAll('.markdown').forEach(elmNode => {
      fisrt_spaces = elmNode.innerHTML.match(/^\n*( *)[^ ]/)[1]
      elmNode.innerHTML = marked.parse(elmNode.innerHTML.replace(new RegExp("\n" + fisrt_spaces, "g"), "\n"))
    });
  </script>
  <script src="drawings.js"></script>
  <script type="module">
    import * as THREE from 'three'
    
    const pi = Math.PI

    function vec_to_euler(vector) {
      return new THREE.Euler().setFromRotationMatrix(new THREE.Matrix4().lookAt(vector, new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0)))
    }

    window.calc_force_init = function (toolbar, scene) {
      // draw shapes
      const wire_shape = new THREE.TorusGeometry( 150, 10, 20, 50 )
      
      const wire1 = new THREE.Group()
      const wire1_material = new THREE.MeshBasicMaterial({ color: 0x3e8207 })
      wire1.name = "wire1"

      // draw circle wire
      const wire1_shape = new THREE.Mesh(wire_shape, wire1_material)
      wire1_shape.name = "wire_shape"
      wire1.add(wire1_shape)

      // draw current flow
      const arrow_1 = new THREE.Mesh(new THREE.ConeGeometry( 25, 55, 32 ), wire1_material)
      arrow_1.position.y = 150
      arrow_1.rotation.z = -pi / 2
      wire1.add(arrow_1)

      const arrow_2 = new THREE.Mesh(new THREE.ConeGeometry( 25, 55, 32 ), wire1_material)
      arrow_2.position.y = -150
      arrow_2.rotation.z = pi / 2
      wire1.add(arrow_2)

      const arrow_3 = new THREE.Mesh(new THREE.ConeGeometry( 25, 55, 32 ), wire1_material)
      arrow_3.position.x = 150
      arrow_3.rotation.z = pi
      wire1.add(arrow_3)

      const arrow_4 = new THREE.Mesh(new THREE.ConeGeometry( 25, 55, 32 ), wire1_material)
      arrow_4.position.x = -150
      wire1.add(arrow_4)

      // transform the whole shape
      wire1.rotation.x = pi/2
      wire1.position.y = 200
      scene.add(wire1)

      // duplicate to wire2
      const wire2_material = new THREE.MeshBasicMaterial({ color: 0x6898cc })
      const wire2 = wire1.clone()
      wire2.name = "wire2";
      wire2.position.y = -200
      wire2.traverse((node) => { if (node.isMesh) { node.material = wire2_material } })
      scene.add(wire2)

      // voltage text
      const voltage = document.createElement('div');
      toolbar.parentElement.appendChild(voltage);
      voltage.style.position = 'absolute';
      voltage.innerHTML = "(blue wire) Voltage: 0";
      voltage.style.top = (toolbar.parentElement.children[0].offsetHeight - voltage.offsetHeight)+'px';
      voltage.style.left = '5%';
      voltage.style.pointerEvents = 'none';
      wire2.voltage = voltage

      // speed arrows
      const wire1_stable = new THREE.Group()
      wire1_stable.name = "wire1_stable"
      wire1_stable.rotation.copy(wire1.rotation.clone().set(-wire1.rotation.x, -wire1.rotation.y, -wire1.rotation.z))
      wire1.add(wire1_stable)

      const speed_1 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,150), 0, wire1_material.color)
      wire1_stable.add(speed_1)

      const speed_2 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,-150), 0, wire1_material.color)
      wire1_stable.add(speed_2)

      const speed_3 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(150,0,0), 0, wire1_material.color)
      wire1_stable.add(speed_3)

      const speed_4 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(-150,0,0), 0, wire1_material.color)
      wire1_stable.add(speed_4)

      // total force arrows
      const force_on_1 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), wire1.position, 0, wire2_material.color)
      force_on_1.name = "force_on_1"
      scene.add(force_on_1)

      const force_on_2 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), wire2.position, 0, wire1_material.color)
      force_on_2.name = "force_on_2"
      scene.add(force_on_2)

      // rotation force arrows
      const circle = new THREE.EllipseCurve(0, 0, 80, 80, 0, 3/2 * pi, false)
      const curve_1_body = new THREE.Line(new THREE.BufferGeometry().setFromPoints( circle.getSpacedPoints(10) ))
      const curve_1_head = new THREE.Mesh(new THREE.ConeGeometry( 15, 40, 32 ))
      curve_1_head.position.y = -80
      curve_1_head.rotation.z = -pi / 2

      const curve_1 = new THREE.Group()
      curve_1.add(curve_1_body)
      curve_1.add(curve_1_head)
      const curve_2 = curve_1.clone()
      curve_2.traverse((node) => { if (node.isMesh) { node.material = node.material.clone() } })

      curve_1.name = "curve_1"
      curve_2.name = "curve_2"

      curve_1.position.set(wire1.position.x, wire1.position.y, wire1.position.z)
      curve_2.position.set(wire2.position.x, wire2.position.y, wire2.position.z)

      curve_1.children.forEach(child => { child.material.color.set(wire2_material.color) })
      curve_2.children.forEach(child => { child.material.color.set(wire1_material.color) })

      curve_1.scale.setScalar(0)
      curve_2.scale.setScalar(0)

      scene.add(curve_1)
      scene.add(curve_2)

      // create force toggle
      const toggle_force = document.createElement('label');
      toggle_force.style.height = "20%";
      toggle_force.style.width = "60%";
      toggle_force.style.margin = "20%";
      toggle_force.classList.add("switch");
      toolbar.children[0].append(toggle_force);

      const input = document.createElement('input');
      input.classList.add("force_type");
      input.type = "checkbox";
      toggle_force.append(input);

      const span = document.createElement('span');
      span.classList.add("slider");
      span.classList.add("round");
      toggle_force.append(span);
      
      const p = document.createElement('p');
      span.append(p);


      // create slidebars
      toolbar.style.height = toolbar.offsetWidth/3+"px";

      const slidebars = document.createElement('div');
      slidebars.style.width = "85%";
      slidebars.style.height = "100%";
      slidebars.style.textAlign = "center";
      toolbar.append(slidebars);

      wire1.speed = new THREE.Vector3( );
      function update_speeds() {
        const length = wire1.speed.length()*25
        speed_1.setLength(length, length*0.2, length*0.2)
        speed_2.setLength(length, length*0.2, length*0.2)
        speed_3.setLength(length, length*0.2, length*0.2)
        speed_4.setLength(length, length*0.2, length*0.2)
        speed_1.setDirection(wire1.speed.clone().normalize())
        speed_2.setDirection(wire1.speed.clone().normalize())
        speed_3.setDirection(wire1.speed.clone().normalize())
        speed_4.setDirection(wire1.speed.clone().normalize())
      }

      const inputs = {
        "R_1": function () { wire1.rotation.x = this.value/100*pi*2 + pi/2 },
        "R_2": function () { wire1.rotation.y = this.value/100*pi*2 },
        "R_3": function () { wire2.rotation.y = this.value/100*pi*2 },
        "V_x": function () { wire1.speed.x = (this.value-50)/10; update_speeds() },
        "V_y": function () { wire1.speed.y = (this.value-50)/10; update_speeds() },
        "V_z": function () { wire1.speed.z = (this.value-50)/10; update_speeds() }
      }
      const height = slidebars.offsetHeight / (Object.keys(inputs).length);
      slidebars.style.fontSize = height*0.8 + "px";
      for(const name in inputs) {
        const part = document.createElement('div');
        part.innerText = name + ": ";
        slidebars.append(part);

        const slidebar = document.createElement('input');
        slidebar.type = 'range';
        slidebar.value = /^V_.$/.test(name) ? 50 : 0;
        slidebar.min = 0;
        slidebar.max = 100;
        slidebar.style.width = "60%";
        slidebar.style.verticalAlign = "middle";
        slidebar.classList.add("measure_slide");
        part.append(slidebar);

        slidebar.onchange = inputs[name];
        slidebar.oninput = inputs[name];
      }
    }

    window.calc_force = function (toolbar, scene) {
      const wire1 = {}
      const wire2 = {}

      const wire1_mesh   = scene.getObjectByName("wire1")
      const wire2_mesh   = scene.getObjectByName("wire2")
      const force_on_1   = scene.getObjectByName("force_on_1")
      const force_on_2   = scene.getObjectByName("force_on_2")
      const curve_1      = scene.getObjectByName("curve_1")
      const curve_2      = scene.getObjectByName("curve_2")
      const wire1_stable = scene.getObjectByName("wire1_stable")

      wire1.radius = wire1_mesh.getObjectByName("wire_shape").geometry.parameters.radius
      wire1.position = wire1_mesh.position
      wire1.rotation = new THREE.Vector3(0, 0, 1).applyEuler(wire1_mesh.rotation)
      const abs_rotation = new THREE.Euler(wire1_mesh.rotation.x + wire1_stable.rotation.x, wire1_mesh.rotation.z + wire1_stable.rotation.z, wire1_mesh.rotation.y + wire1_stable.rotation.y, "XYZ")
      wire1.speed = wire1_mesh.speed.clone().applyEuler(abs_rotation)

      wire2.radius = wire2_mesh.getObjectByName("wire_shape").geometry.parameters.radius
      wire2.position = wire2_mesh.position
      wire2.rotation = new THREE.Vector3(0, 0, 1).applyEuler(wire2_mesh.rotation)
      wire2.voltage = 0

      const mine_force = toolbar.children[0].children[1].children[0].checked
      const voltage = wire2_mesh.voltage

      const F_1_T = new THREE.Vector3()
      const F_2_T = new THREE.Vector3()
      const F_1_rotating_T = new THREE.Vector3()
      const F_2_rotating_T = new THREE.Vector3()
      let parts = 100

      // creating new axis on circles
      const new_x_1 = Math.round(wire1.rotation.x, 4) == 0 ? wire1.rotation.clone().cross(new THREE.Vector3(1,0,0)) : wire1.rotation.clone().cross(new THREE.Vector3(0,1,0))
      new_x_1.normalize()
      const new_y_1 = wire1.rotation.clone().cross(new_x_1)
      const radius_1_x = new_x_1.clone().multiplyScalar(wire1.radius)
      const radius_1_y = new_y_1.clone().multiplyScalar(wire1.radius)

      const new_x_2 = Math.round(wire2.rotation.x, 4) == 0 ? wire2.rotation.clone().cross(new THREE.Vector3(1,0,0)) : wire2.rotation.clone().cross(new THREE.Vector3(0,1,0))
      new_x_2.normalize()
      const new_y_2 = wire2.rotation.clone().cross(new_x_2)
      const radius_2_x = new_x_2.clone().multiplyScalar(wire2.radius)
      const radius_2_y = new_y_2.clone().multiplyScalar(wire2.radius)

      let area_value = 0
      const areas = []
      if (!mine_force) {
        // calculate which parts are in the circle
        // step = sqrt(circle area / square area) * whole distance to make / in how much steps
        const step = Math.sqrt((wire2.radius*wire2.radius*pi) / (2*wire2.radius*2*wire2.radius)) * (2*wire2.radius) / Math.sqrt(parts)
        let height = -wire2.radius
        let width = -wire2.radius

        while (height < wire2.radius) {
          if (Math.hypot(width, height) <= wire2.radius) {
            areas.push(new_x_2.clone().multiplyScalar(width).add(new_y_2.clone().multiplyScalar(height)).add(wire2.position))
          }

          width += step
          if (width > wire2.radius) {
            width = -wire2.radius
            height += step
          }
        }
        parts = areas.length
        area_value = step*step
      }
      for (let part1 = 0; part1 < parts; part1++) {
        for (let part2 = 0; part2 < parts; part2++) {
          const alpha = 2*pi * part1/parts;
          const beta  = 2*pi * part2/parts;

          const relative_place_1 = radius_1_x.clone().multiplyScalar(Math.sin(alpha)).add(radius_1_y.clone().multiplyScalar(Math.cos(alpha)));
          const relative_place_2 = radius_2_x.clone().multiplyScalar(Math.sin(beta)).add(radius_2_y.clone().multiplyScalar(Math.cos(beta)));

          const v_1 = wire1.rotation.clone().cross(relative_place_1).normalize();
          const v_2 = wire2.rotation.clone().cross(relative_place_2).normalize();

          const absolute_place_1 = wire1.position.clone().add(relative_place_1)
          const absolute_place_2 = wire2.position.clone().add(relative_place_2)

          const R = absolute_place_1.clone().sub(absolute_place_2)
          const R_hat = R.clone().normalize()

          let f_1 = null
          let f_2 = null

          if (mine_force) {
            // TODO when i will add constants into the equations, notice that my v_1 and v_2 values are always 1, and i relay on that in some calculations. so just muliply the apropiate q for the matching I.

            // full "mine" force calculation
            const v_1_n = v_1.clone().add(wire1.speed)
            const v_2_n = v_2
            const v_1_p = wire1.speed.clone()
            const v_2_p = new THREE.Vector3()

            const top_p_n = + Math.pow(v_1_p.clone().sub(v_2_n).length(), 2) - 3/2*Math.pow(v_1_p.clone().dot(R_hat) - v_2_n.clone().dot(R_hat), 2)
            const top_n_p = + Math.pow(v_1_n.clone().sub(v_2_p).length(), 2) - 3/2*Math.pow(v_1_n.clone().dot(R_hat) - v_2_p.clone().dot(R_hat), 2)
            const top_n_n = - Math.pow(v_1_n.clone().sub(v_2_n).length(), 2) + 3/2*Math.pow(v_1_n.clone().dot(R_hat) - v_2_n.clone().dot(R_hat), 2)
            const top_p_p = - Math.pow(v_1_p.clone().sub(v_2_p).length(), 2) + 3/2*Math.pow(v_1_p.clone().dot(R_hat) - v_2_p.clone().dot(R_hat), 2)

            f_2 = R_hat.clone().multiplyScalar( (top_p_n + top_n_p + top_n_n + top_p_p) / (Math.pow(R.length(), 2)) )
            f_1 = f_2.clone().negate()

            // check whats f_positive_2 - f_positive_1 to know the forces difference for the voltage
            // const field_difference = R_hat.clone().multiplyScalar( ((top_p_n + top_n_n) - (top_n_p + top_p_p)) / (Math.pow(R.length(), 2)) )
            const field_difference = R_hat.clone().multiplyScalar( (top_p_n + top_n_n) / (Math.pow(R.length(), 2)) )
            // check its vlue in the wire direction because on other directions the electricity cant flow
            const field_difference_in_wire_direction = field_difference.clone().dot(v_2.clone().normalize())
            const distance = 2*pi*wire2.radius / parts
            // voltage = how much energy it takes to move a 1 charge from point A to point B
            wire2.voltage += field_difference_in_wire_direction * distance
          } else {
            // "their" force calculation
            f_1 = v_2.clone().cross(R_hat.clone().negate()).cross(v_1).divideScalar(Math.pow(R.length(), 2))
            f_2 = v_1.clone().cross(R_hat                 ).cross(v_2).divideScalar(Math.pow(R.length(), 2))

            const dt = 0.00001
            const area_place = areas[part2]

            const R_A_old = absolute_place_1.clone().sub(area_place)
            const R_A_hat_old = R_A_old.clone().normalize()
            const old_flux = v_1.clone().cross(R_A_hat_old).dot(wire2.rotation) / Math.pow(R_A_old.length(), 2) * area_value

            const R_A_new = absolute_place_1.clone().add(wire1.speed.clone().multiplyScalar(dt)).sub(area_place)
            const R_A_hat_new = R_A_new.clone().normalize()
            const new_flux = v_1.clone().cross(R_A_hat_new).dot(wire2.rotation) / Math.pow(R_A_new.length(), 2) * area_value

            wire2.voltage += (new_flux - old_flux) / dt
          }

          F_1_T.add(f_1)
          F_2_T.add(f_2)

          F_1_rotating_T.add(relative_place_1.clone().cross(f_1))
          F_2_rotating_T.add(relative_place_2.clone().cross(f_2))
        }
      }

      // add dx (doing f/(parts*parts) is the same as doing f*q1*q2)
      F_1_T.divideScalar(parts*parts)
      F_2_T.divideScalar(parts*parts)
      F_1_rotating_T.divideScalar(parts*parts)
      F_2_rotating_T.divideScalar(parts*parts)
      wire2.voltage /= parts

      // scale for better display
      wire2.voltage   *= 2_670.7946485
      const foce_const = 267_079_464.85
      F_1_T.multiplyScalar(foce_const)
      F_2_T.multiplyScalar(foce_const)
      F_1_rotating_T.multiplyScalar(foce_const*2/3)
      F_2_rotating_T.multiplyScalar(foce_const*2/3)

      // update total force arrows
      force_on_1.setDirection(F_1_T.clone().normalize())
      force_on_1.setLength(F_1_T.length(), F_1_T.length()*0.2, F_1_T.length()*0.2)
      force_on_2.setDirection(F_2_T.clone().normalize())
      force_on_2.setLength(F_2_T.length(), F_2_T.length()*0.2, F_2_T.length()*0.2)

      // update rotation force arrows
      curve_1.scale.setScalar(F_1_rotating_T.length() / 20500)
      curve_2.scale.setScalar(F_2_rotating_T.length() / 20500)
      curve_1.rotation.setFromVector3(vec_to_euler(F_1_rotating_T))
      curve_2.rotation.setFromVector3(vec_to_euler(F_2_rotating_T))

      // update voltage
      voltage.innerHTML = voltage.innerHTML.replace( new RegExp(": .*$","gm"),": " + (wire2.voltage).toFixed(2))
    }

    draw_symbols_explanation()
    draw_vertical_symbol()
  </script>
  <script id="CanvasVideo" type="module" src="./canvas_video/animation.js"></script>
</body>

</html>